//Section 15.8 Containers and Inheritance
//Ex15.28, p 631, Define a vector to hold Quote objects but put BulkQuote objects into that vector. Compute the total NetPrice of all the elements in the vector.
//Ex15.29, Repeat your program, but this time store shared_ptrs to objects of type Quote. Explain any discrepancy in the sum generated by this version and the previous program. If there is no discrepancy, explain why there isn't one.
//++ touch and feel the error, and make corrections QUICKLY, 
//'make_shared<Quote>(lq)' create a shared_pointer to Quote from a LimitedQuote object lq, which is a laughter.

#include <iostream>
#include <string>
#include <vector>

using std::string; using std::vector;

//refactored Quote hierarchy to accomodate the testing
class Quote {
public:
    Quote () = default;
    Quote (string b, size_t o, double p) :BookNo{b},Order {o}, Price{p} {}   
    string isbn () const {return BookNo;}
    virtual double NetPrice () const {return Order*Price;}
    virtual ~Quote () = default;
    
private:
    string BookNo;     
    
protected:
    size_t Order = 0;
    double Price = 0.0;

};

class DiscQuote : public Quote{
public:
	DiscQuote () = default;
	DiscQuote (const string& book, size_t o, double p, size_t m, double d) 
		: Quote(book, o, p), Bound {m},Discount(d) {}
	virtual double NetPrice () const override = 0 ;
	
protected:		
	size_t Bound = 0;
	double Discount = 0.0;
};

class BulkQuote : public DiscQuote
{
public:
    BulkQuote () = default;
    BulkQuote (const string& book, size_t o, double p, size_t m, double d) 
    	: DiscQuote(book, o, p,m,d) {}
    virtual double NetPrice () const override {
        if(Order >= Bound)
            return Order * Price * (1-Discount);
        return Order * Price;
    }
};

class LimitedQuote : public DiscQuote
{
public:
	LimitedQuote () = default;
	LimitedQuote (const string& book, size_t o, double p, size_t m, double d) 
    	: DiscQuote(book, o,p,m,d) {}
    virtual double NetPrice () const override {
		if(Order <= Bound)
			return Order * Price * (1-Discount);
		return
			Order*Price - Bound*Price*Discount;
	}
};

//PrintTotal
double PrintTotal(std::ostream& os, const Quote& quote){
    double Total = quote.NetPrice();
    os << "Book: " << quote.isbn() << "\ntotal: " << Total << std::endl;
    return Total;
}


int main (){
	double CorrectSum = 0.0;	// calculate the correct sum
	
    Quote q("C++ Primer, 5th", 1, 89.5);
    CorrectSum += PrintTotal(std::cout, q);	
    
    BulkQuote bq ("C++ Primer, 5th", 100, 89.5, 10, 0.1);
    CorrectSum += PrintTotal(std::cout, bq);
    
    LimitedQuote lq ("C++ Primer, 5th", 100, 89.5, 10, 0.1);
    CorrectSum += PrintTotal(std::cout, lq);
    
    std::cout << CorrectSum << std::endl;
    
    //Ex15.28
    //reproduce the incorrect sum
    vector<Quote> v {q, bq, lq};
    double ObjectSum = 0.0;	
    for(const auto &i : v){
    	ObjectSum += PrintTotal(std::cout, i);
    }
    std::cout << ObjectSum << std::endl;
    
    //15.29
    //get the correct total by another route
    vector<shared_ptr<Quote>> p;
    shared_ptr<Quote> m = make_shared<Quote>(q);
    p.push_back(m);
    m = make_shared<BulkQuote>(bq);
    p.push_back(m);
    m = make_shared<LimitedQuote>(lq);	//last stroke to finish the drawing
    p.push_back(m);
    
    double PointerSum = 0.0;
    for(const auto &i : p){
    		PointerSum += PrintTotal(std::cout, *i);
    }
    std::cout << PointerSum << std::endl;	//success!
    
    
    return 0;
    
}



